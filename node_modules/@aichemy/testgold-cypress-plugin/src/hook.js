const { getInterceptorConfig, getTagMutationTable, startTestRequest,
  serializeWebElement, getSelectorId, findSimilarElements, getPageProperties, awaitableTimeout } = require('./utils')
const { cssRequest } = require('./cssRequest')

/**
 * Runs the actual interceptor hook to talk to the WAL server and heal selector
 * @param selector
 * @param Cypress
 * @param cy
 * @param state
 * @param walServerRequestId
 * @param interceptorConfig
 * @param ignoreList {Array<string>}
 * @returns Object
 */
async function interceptorHook (
  selector,
  Cypress, cy, state,
  walServerRequestId = null,
  interceptorConfig = null,
  ignoreList = null
) {
  if (ignoreList !== null && ignoreList.indexOf(selector) !== -1) {

    Cypress.log({
      name: '[TGI]',
      message: `‚≠ï Not processing selector: ${selector} because it is on the ignore list.`,
    })

    return {
      status: 'interceptor disabled, selector is on the ignore list',
      interceptorConfig,
    }

  }

  // check if the interceptor is enabled
  if (interceptorConfig === null) {
    interceptorConfig = getInterceptorConfig(Cypress)
  }

  let interceptorResult = {
    status: 'interceptor disabled',
    interceptorConfig,
  }

  // if it's not, return immediately
  if (interceptorConfig.tgEnabled === false) {
    return interceptorResult
  }

  Cypress.log({
    name: '[TGI]',
    message: `üîÑ Processing selector: ${selector}`,
  })

  // sequence:
  // 1. get the tag mutation table
  // 2. get the test request ID
  // 3. collect body HTML and page properties
  // 4. collect selected element info and decide whether to trigger healing

  try {
    // get a new walServerRequestId if one is not provided
    if (walServerRequestId === null) {
      walServerRequestId = await startTestRequest(Cypress, interceptorConfig)
    }

    if (walServerRequestId === null) {
      interceptorResult['status'] = 'interceptor disabled'

      return interceptorResult
    }

    let tagMutationTable

    try {
      tagMutationTable = await getTagMutationTable(interceptorConfig)
    } catch (err) {
      tagMutationTable = null
    }

    //
    // start the interceptor processing
    //

    // put the selector, walServerRequestId, and interceptorConfig into the interceptorResult
    interceptorResult['selector'] = selector
    interceptorResult['walServerRequestId'] = walServerRequestId
    interceptorResult['interceptorConfig'] = interceptorConfig
    interceptorResult['specFileName'] = Cypress.spec.name

    // NOTE: this is the REMOTE window object (i.e. the one under test)
    //   using Cypress.$(window) would have given us the window object of the
    //   Cypress runner itself (which includes the remote window in a frame)
    let $window = state('window')
    let $document = state('document')

    // try a few times to get the selected element, this allows the DOM
    // to settle before running the jQuery select
    const tryWaitList = [
      50, 100, 150, 200, 250,
      300, 350, 400, 450, 500,
      550, 600, 650, 700, 750,
    ];

    let $result = []
    let randomWait = 0

    for (let waitTime of tryWaitList) {
      randomWait = Math.round(100 * Math.abs(Math.random() - 0.5))
      await awaitableTimeout(waitTime + randomWait)
      $result = Cypress.$(selector)
      if ($result.length > 0) {
        break
      }
    }

    // get the other properties after the target element selection is resolved

    let pageUrl = $window.location.href
    // break up the pageUrl into its components
    let { pathname: urlPath } = new URL(pageUrl)

    // make JS follow Python and Java
    if (urlPath === '/') {
      urlPath = ''
    }

    // get the selectorId and put it into the interceptorResult object
    let selectorId = getSelectorId(selector, urlPath)

    interceptorResult['selectorId'] = selectorId

    // REMOTE body object (since Cypress.$('<something>') is scoped to the REMOTE window)
    let $body = Cypress.$('body')[0]
    let bodyHtml = $body.parentNode.outerHTML

    // attempt to scroll to the target element before further processing (+ screenshot)
    if ($result.length > 0) {
      $result[0].scrollIntoView()
      await awaitableTimeout(150)
    }

    // page properties
    let pageProperties = getPageProperties($window, $document, Cypress)

    interceptorResult['pageProperties'] = pageProperties

    //
    // if selector succeeded - run the train-flow
    //

    if ($result.length > 0) {
      Cypress.log({
        name: '[TGI]',
        message: `‚úÖ Selector: ${selector} succeeded. Starting train-flow...`,
      })

      // tell the interceptorResult what kind of request will be sent
      interceptorResult['postRequestType'] = 'initial'

      let serializedWebElement = serializeWebElement($window, $result[0], Cypress, cy)

      // divert to fast-train if requested
      if (interceptorConfig['interceptorFastHeal']) {
        let fastTrainRequest = new cssRequest(
          selector,
          pageUrl,
          'initial',
          interceptorConfig['walServerHost'],
          interceptorConfig['walAuthToken'],
          interceptorConfig['walServerUser'],
          walServerRequestId,
          interceptorConfig['walServerTimeout'],
        )

        fastTrainRequest.selectorId = selectorId
        fastTrainRequest.addSelectedElement(serializedWebElement)
        fastTrainRequest.addBodyHTML(bodyHtml)
        fastTrainRequest.addBrowserProperties(
          pageProperties['viewportWidth'],
          pageProperties['viewportHeight'],
          pageProperties,
        )

        // screenshots are sent out-of-band
        fastTrainRequest.addScreenshot(null)

        let fastTrainResponse = await fastTrainRequest.sendFastTrainRequest()

        // if the fast-train request succeeded, we can end here and return the results
        if (fastTrainResponse['status'] === 'queued') {
          interceptorResult['status'] = 'trained successfully'
          interceptorResult['postSentAt'] = fastTrainRequest.sentAt

          return interceptorResult
        }

        //
        // otherwise, we'll need to fall back to normal train
        //
      }

      // get the similar web elements
      let similarWebElements = await findSimilarElements(
        serializedWebElement,
        selector,
        selectorId,
        $window,
        $document,
        tagMutationTable,
        interceptorConfig,
        Cypress,
        cy,
      )

      // generate the train request and send it
      let trainRequest = new cssRequest(
        selector,
        pageUrl,
        'initial',
        interceptorConfig['walServerHost'],
        interceptorConfig['walAuthToken'],
        interceptorConfig['walServerUser'],
        walServerRequestId,
        interceptorConfig['walServerTimeout'],
      )

      trainRequest.selectorId = selectorId
      trainRequest.addBodyHTML(bodyHtml)
      trainRequest.addSelectedElement(serializedWebElement)
      trainRequest.addSimilarElements(similarWebElements)

      trainRequest.addBrowserProperties(
        pageProperties['viewportWidth'],
        pageProperties['viewportHeight'],
        pageProperties,
      )

      // FIXME: can't do screenshots yet
      trainRequest.addScreenshot(null)

      // send the train request
      await trainRequest.sendTrainPostRequest()

      interceptorResult['status'] = 'trained successfully'
      interceptorResult['postSentAt'] = trainRequest.sentAt

      return interceptorResult
    }

    //
    // heal-flow -- if the element was not found
    //
    Cypress.log({
      name: '[TGI]',
      message: `‚ö†Ô∏è Selector: ${selector} failed. Starting heal-flow...`,
      consoleProps: () => {
        return interceptorConfig
      },
    })

    // tell the interceptor we'll be sending a followup request
    interceptorResult['postRequestType'] = 'followup'

    // divert to fast-heal if requested
    if (interceptorConfig['interceptorFastHeal'] === true) {
      let fastHealRequest = new cssRequest(
        selector,
        pageUrl,
        'fastHeal',
        interceptorConfig['walServerHost'],
        interceptorConfig['walAuthToken'],
        interceptorConfig['walServerUser'],
        walServerRequestId,
        interceptorConfig['walServerTimeout'],
      )

      fastHealRequest.selectorId = selectorId
      fastHealRequest.addBodyHTML(bodyHtml)
      fastHealRequest.addBrowserProperties(
        pageProperties['viewportWidth'],
        pageProperties['viewportHeight'],
        pageProperties,
      )

      // send the fast-heal request
      let fastHealResp = await fastHealRequest.sendFastHealRequest()

      if (fastHealResp['status'] === 'success' || fastHealResp['status'] === 'warning') {
        interceptorResult['healedSelector'] = fastHealResp['bestSelector']
        interceptorResult['status'] = 'selector failed, heal OK'
        interceptorResult['processingType'] = 'heal'
        interceptorResult['details'] = fastHealResp
        interceptorResult['postSentAt'] = fastHealRequest.sentAt

        Cypress.log({
          name: '[TGI]',
          message: `‚öõÔ∏è The TG API fast-healed this to: ${interceptorResult['healedSelector']}.`,
        })

        return interceptorResult
      }
    }

    //
    // if fast-heal didn't work, continue with normal-heal
    //

    // get the similar web elements -- pass null to the serializedWebElement param to signal
    // this will be a followup request
    let similarWebElements = await findSimilarElements(
      null,
      selector,
      selectorId,
      $window,
      $document,
      tagMutationTable,
      interceptorConfig,
      Cypress,
      cy,
    )

    // generate the followup request
    let followupRequest = new cssRequest(
      selector,
      pageUrl,
      'followup',
      interceptorConfig['walServerHost'],
      interceptorConfig['walAuthToken'],
      interceptorConfig['walServerUser'],
      walServerRequestId,
      interceptorConfig['walServerTimeout'],
    )

    // add in the required items
    followupRequest.selectorId = selectorId
    followupRequest.addBodyHTML(bodyHtml)
    followupRequest.addSimilarElements(similarWebElements)

    followupRequest.addBrowserProperties(
      pageProperties['viewportWidth'],
      pageProperties['viewportHeight'],
      pageProperties,
    )

    // screenshots are sent out of band
    followupRequest.addScreenshot(null)

    // send the followup request
    let followupResp = await followupRequest.sendTrainPostRequest()

    interceptorResult['postSentAt'] = followupRequest.sentAt

    // if the followup POST was accepted, start waiting for the heal response
    // and handle it
    if (followupResp['status'] !== 'failed') {
      let healResp = await followupRequest.sendHealOrSuggestGetRequest('heal', Cypress)

      if (healResp['status'] === 'success' || healResp['status'] === 'warning') {
        interceptorResult['healedSelector'] = healResp['bestSelector']
        interceptorResult['status'] = 'selector failed, heal OK'
        interceptorResult['processingType'] = 'heal'
        interceptorResult['details'] = healResp

        Cypress.log({
          name: '[TGI]',
          message: `‚öõÔ∏è The TG API healed this to: ${interceptorResult['healedSelector']}.`,
        })

        return interceptorResult
      }
    }

    // otherwise, the follow-up request was not accepted, then we need to fall back to
    // css-suggest if the interceptor is setup to do so
    if (interceptorConfig['interceptorHandleFailure'] === 'suggest-xpaths') {
      Cypress.log({
        name: '[TGI]',
        message: `‚ö†Ô∏è Selector: ${selector} could not be healed. Starting suggest-flow...`,
      })

      // tell the interceptorResult what kind of request will be sent
      interceptorResult['postRequestType'] = 'suggest'

      // send the suggest POST request to make the WAL server aware
      let suggestPostResp = await followupRequest.sendSuggestPostRequest()

      interceptorResult['postSentAt'] = followupRequest.sentAt

      if (suggestPostResp === null || suggestPostResp === undefined) {
        interceptorResult['status'] = 'failed'
        interceptorResult['processingType'] = 'suggest'

        Cypress.log({
          name: '[TGI]',
          message: '‚ùé The TG API had no training data for this selector and could not suggest an alternative.',
        })

        return interceptorResult
      }

      // get back the suggestion results
      let suggestGetResp = await followupRequest.sendHealOrSuggestGetRequest('suggest', Cypress)

      if (suggestGetResp['status'] === 'success' || suggestGetResp['status'] === 'warning') {
        if (suggestGetResp['suggestedFixes'] !== null) {
          interceptorResult['healedSelector'] = suggestGetResp['suggestedFixes']['candidateSelectors'][0]
          interceptorResult['status'] = 'selector failed, heal OK'
          interceptorResult['processingType'] = 'suggest'
          interceptorResult['details'] = suggestGetResp

          Cypress.log({
            name: '[TGI]',
            message: '‚öõÔ∏è The TG API had no training data for this selector.',
          })

          Cypress.log({
            name: '[TGI]',
            message: `‚öõÔ∏è The best-effort heal attempt returned an alternative selector: ${interceptorResult['healedSelector']}.`,
          })

          Cypress.log({
            name: '[TGI]',
            message: `‚öõÔ∏è Please check if this selector works as expected.`,
          })

          return interceptorResult
        }

        //
        // if the suggestGetResp is null, the WAL server failed
        //
        interceptorResult['status'] = 'failed'
        interceptorResult['processingType'] = 'suggest'
        interceptorResult['details'] = suggestGetResp

        Cypress.log({
          name: '[TGI]',
          message: '‚ùé The TG API had no training data for this selector and could not suggest an alternative.',
        })

        return interceptorResult
      }
    }

    //
    // interceptorHandleFailure is not set to 'suggest-xpaths', so we can't use suggestions
    //
    Cypress.log({
      name: '[TGI]',
      message: '‚ùé The TG API had no training data for this selector and could not suggest an alternative.',
    })

    interceptorResult['status'] = 'failed'

    return interceptorResult
  } catch (err) {
    // catch all other errors and error out
    interceptorResult['status'] = 'failed'
    Cypress.log({
      name: '[TGI]',
      message: `‚õîÔ∏è Could not process selector: ${selector}, exception raised.`,
      consoleProps: () => {
        return {
          'error': err,
          'stackTrace': (new Error()).stack,
        }
      },
    })

    return interceptorResult
  }
}

module.exports = {
  interceptorHook,
}
