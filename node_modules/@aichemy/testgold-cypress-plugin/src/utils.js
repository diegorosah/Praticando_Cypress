/* global Cypress, fetch, window */

const { decodeBase64Unicode } = require('./extra_utils')
const $dom = Cypress.dom
const parsel = require('./bundled_parsel')
const jsSHA = require('jssha/dist/sha')

/**
 * Waits for the given amount of time and resolves with a Promise.
 *
 * // https://stackoverflow.com/a/33292942
 *
 * @param ms
 * @returns {Promise<*>}
 */
async function awaitableTimeout (ms) {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

/**
 * Generates the selectorId for a CSS selector
 * @param selector
 * @param urlPath
 * @returns {string}
 */
function getSelectorId (selector, urlPath) {
  const selectorDigest = `${urlPath}|${selector}`
  const hasher = new jsSHA('SHA-256', 'TEXT', { encoding: 'UTF8' })

  hasher.update(selectorDigest)

  return hasher.getHash('HEX')
}

/**
 * Serializes the WebElement.
 *
 * Optionally filters out disabled and invisible elements and elements that are not nearest neighbors.
 *
 * @param $window window object
 * @param $elem DOM.Element object
 * @param Cypress instance of Cypress object
 * @param cy instance of Cy object
 * @param filterVisible true if only visible elements should be counted
 * @param filterEnabled true if only enabled elements should be counted
 * @param nearestNeighborSpec tuple of (otherX, otherY, maxDistPx) if elements more than maxDistPx away should not be counted
 */
function serializeWebElement (
  $window,
  $elem,
  Cypress,
  cy,
  filterVisible = false,
  filterEnabled = false,
  nearestNeighborSpec = null,
) {
  // get disabled state of element
  let isDisabled = $elem.getAttribute('disabled') === true

  if (filterEnabled && isDisabled) {
    return null
  }

  // compute isDisplayed property of the element
  // use cypress' dom.isVisible() utility
  let elemIsDisplayed = $dom.isVisible($elem)

  if (filterVisible && !elemIsDisplayed) {
    return null
  }

  // get the window properties
  let scrollX = $window.scrollX
  let scrollY = $window.scrollY

  // get the element properties
  let elementTagName = $elem.tagName.toLowerCase()
  let elementId = $elem.id
  let elemName = $elem.getAttribute('name')
  let elemClass = $elem.getAttribute('class')
  let elemRect = $elem.getBoundingClientRect()

  // getBoundingClientRect() returns coordinates relative to the viewport
  // we need to convert these to coordinates that are relative to the document
  // https://www.w3.org/TR/webdriver/#dfn-calculate-the-absolute-position
  let elemX = elemRect.left + scrollX
  let elemY = elemRect.top + scrollY

  // filter if nearestNeighborSpec is given
  if (nearestNeighborSpec !== null) {
    let [otherX, otherY, maxDistPx] = nearestNeighborSpec
    let thisDist = Math.sqrt(
      (otherX - elemX) * (otherX - elemX) +
      (otherY - elemY) * (otherY - elemY),
    )

    if (thisDist > maxDistPx) {
      return null
    }
  }

  let elemWidth = elemRect.width
  let elemHeight = elemRect.height
  let elementInnerHtml = $elem.innerHTML
  let elementOuterHtml = $elem.outerHTML
  let elementText = $elem.innerText

  return {
    elementId: 'cypress-does-not-have-elementIds',
    elementType: 'cypress-interceptor',
    text: elementText,
    tag: elementTagName,
    width: elemWidth,
    height: elemHeight,
    x: elemX,
    y: elemY,
    elemViewLeft: elemRect.left,
    elemViewTop: elemRect.top,
    elemViewRight: elemRect.right,
    elemViewBottom: elemRect.bottom,
    windowScrollX: scrollX,
    windowScrollY: scrollY,
    isEnabled: !isDisabled,
    isDisplayed: elemIsDisplayed,
    cssClass: elemClass,
    htmlName: elemName,
    htmlId: elementId,
    outerHtml: elementOuterHtml,
    innerHtml: elementInnerHtml,
  }
}

/**
 * Gets the interceptor config from the cypress.json file.
 *
 * @param Cypress
 * @param getTestRunName
 * @returns {{walAuthToken, walServerUser, walServerHost, interceptorNeighborMaxDist: number, interceptorFastHeal: boolean, interceptorHandleFailure: string, interceptorFilterDisplayed: boolean, tgEnabled: boolean, testRunName, interceptorFilterEnabled: boolean, walServerTimeout: number}|{tgEnabled: boolean}}
 */
function getInterceptorConfig (Cypress, getTestRunName = false) {
  const tgConfig = Cypress.config('testGold')
  let tgEnabled = false

  if (tgConfig === undefined || tgConfig === null) {
    return {
      tgEnabled: false,
    }
  }

  let envTgEnabled = Cypress.env('TG_ENABLED')

  if (envTgEnabled === undefined || envTgEnabled === null) {
    return {
      tgEnabled: false,
    }
  }

  tgEnabled = envTgEnabled.toString().toLowerCase() === 'true'

  if (!tgEnabled) {
    return {
      tgEnabled: false,
    }
  }

  let envTgToken = Cypress.env('TG_TOKEN')

  if (envTgToken === undefined || envTgToken === null) {
    return {
      tgEnabled: false,
    }
  }

  let decodedToken = null

  try {
    decodedToken = JSON.parse(decodeBase64Unicode(envTgToken))
  } catch (err) {
    Cypress.log({
      name: '[TGI]',
      message: `Could not parse the value of CYPRESS_TG_TOKEN. The cypress-testgold-plugin has been disabled.`,
    })

    return {
      tgEnabled: false,
    }
  }

  // WAL server specific bits
  const walAuthToken = decodedToken['walAuthToken']
  const walServerHost = decodedToken['walServerHost']
  const walServerUser = decodedToken['walServerUser']
  let walServerTimeout = tgConfig['serverTimeout']

  if (walServerTimeout === undefined || walServerTimeout === null) {
    walServerTimeout = 180.0
  }

  // interceptor options
  let interceptorHandleFailure = tgConfig['handleFailure']

  if (interceptorHandleFailure === undefined || interceptorHandleFailure === null) {
    interceptorHandleFailure = 'suggest-xpaths'
  }

  let interceptorFilterEnabled = tgConfig['filterEnabled']

  if (interceptorFilterEnabled === undefined || interceptorFilterEnabled === null) {
    interceptorFilterEnabled = true
  }

  let interceptorFilterDisplayed = tgConfig['filterDisplayed']

  if (interceptorFilterDisplayed === undefined || interceptorFilterDisplayed === null) {
    interceptorFilterDisplayed = true
  }

  let interceptorNeighborMaxDist = tgConfig['neighborMaxDist']

  if (interceptorNeighborMaxDist === undefined || interceptorNeighborMaxDist === null) {
    interceptorNeighborMaxDist = 300.0
  }

  let interceptorFastHeal = tgConfig['fastHeal']

  // NOTE: fast-heal is now on by default
  if (interceptorFastHeal === undefined || interceptorFastHeal === null) {
    interceptorFastHeal = true
  }

  let interceptorImageComparison = tgConfig['imageComparison']

  if (interceptorImageComparison === undefined || interceptorImageComparison === null) {
    interceptorImageComparison = false
  }

  let interceptorTakeScreenshots = tgConfig['takeScreenshots']

  if (interceptorTakeScreenshots === undefined || interceptorTakeScreenshots === null) {
    interceptorTakeScreenshots = true
  }

  // get the test run name (this is the cypress spec filename)
  let testRunName = null

  if (getTestRunName === true) {
    testRunName = Cypress.spec.name
  }

  return {
    tgEnabled,
    walAuthToken,
    walServerHost,
    walServerUser,
    walServerTimeout,
    interceptorHandleFailure,
    interceptorFilterEnabled,
    interceptorFilterDisplayed,
    interceptorNeighborMaxDist,
    interceptorFastHeal,
    interceptorImageComparison,
    interceptorTakeScreenshots,
    testRunName,
  }
}

function getPageProperties ($window, $document) {
  let body = $document.body
  let documentElement = $document.documentElement

  let pageHeight = Math.max(
    body.scrollHeight,
    body.offsetHeight,
    documentElement.clientHeight,
    documentElement.scrollHeight,
    documentElement.offsetHeight,
  )
  let viewportHeight = (
    $window.innerHeight || documentElement.clientHeight || body.clientHeight
  )
  let viewportWidth = (
    $window.innerWidth || documentElement.clientWidth || body.clientWidth
  )

  let yOffset = $window.pageYOffset || 0
  let xOffset = $window.pageXOffset || 0
  let devicePixelRatio = $window.devicePixelRatio

  let retObj = {
    pageHeight,
    viewportHeight,
    viewportWidth,
    xOffset,
    yOffset,
    devicePixelRatio,
    interceptor: 'cypress',
  }

  let cypressDoc = window.parent.document
  let appFrameContainer = cypressDoc.querySelector('.aut-iframe')

  if (appFrameContainer !== null && appFrameContainer !== undefined) {
    let appFrameBox = appFrameContainer.getBoundingClientRect()

    retObj.iframeDimensions = {
      left: appFrameBox.left,
      top: appFrameBox.top,
      bottom: appFrameBox.bottom,
      right: appFrameBox.right,
    }
  }

  return retObj
}

/**
 * Gets the tag mutation table from the WAL server.
 *
 * @param tgConfig
 * @returns {Promise<*>}
 */
async function getTagMutationTable (tgConfig) {
  const resp = await fetch(
    `${tgConfig.walServerHost}/tag-mutations/v1`,
    {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${tgConfig.walAuthToken}`,
      },
    },
  )

  // if no tag-mutation table is available, we'll fall back to using all elements in the DOM
  if (!resp.ok) {
    return null
  }

  return await resp.json()
}

/**
 * Starts the test request and asks for a walServerRequestId from the WAL server
 * @param Cypress
 * @param tgConfig
 * @returns {Promise<Promise|Promise|*>}
 */
async function startTestRequest (Cypress, tgConfig) {
  const url = `${tgConfig['walServerHost']}/testrequest/v1`

  let postData = new URLSearchParams({
    scriptType: 'javascript',
    testRunName: `Cypress: ${tgConfig['testRunName']}`,
    userName: tgConfig['walServerUser'],
    handleFailure: tgConfig['interceptorHandleFailure'],
    filterDisabled: tgConfig['interceptorFilterEnabled'],
    filterInvisible: tgConfig['interceptorFilterDisplayed'],
    fastHeal: tgConfig['interceptorFastHeal'],
    imageComparison: tgConfig['interceptorImageComparison'],
    takeScreenshots: tgConfig['interceptorTakeScreenshots'],
    neighborMaxDist: tgConfig['interceptorNeighborMaxDist'],
  })

  let resp = await fetch(
    url,
    {
      headers: {
        Authorization: `Bearer ${tgConfig['walAuthToken']}`,
        'content-type': 'application/x-www-form-urlencoded',
      },
      body: postData,
      method: 'POST',
    },
  )

  // if the response is not OK, reject the Promise to disable the interceptor
  // because we can't get a test request ID
  if (!resp.ok) {
    Cypress.log({
      name: '[TGI]',
      message: `⛔️ Initiating TG API test request failed: ${resp.statusText}, this test will not be healing-enabled.`,
    })

    return null
  }

  let respData = await resp.json()

  return respData['walServerRequestId']
}

/**
 * Finishes a currently running WAL server test request.
 *
 * @param requestId
 * @param tgConfig
 * @param Cypress
 * @returns {Promise<string>}
 */
async function finishTestRequest (requestId, tgConfig, Cypress) {
  if (tgConfig['enabled'] === false || (tgConfig['walAuthToken'] === undefined || tgConfig['walAuthToken'] === null)) {
    return new Promise((resolve) => {
      resolve('This test run has been marked as "finished".')
    })
  }

  let url = `${tgConfig['walServerHost']}/testrequest/v1`

  let putData = new URLSearchParams({
    requestId,
  })

  let resp = await fetch(
    url,
    {
      headers: {
        Authorization: `Bearer ${tgConfig['walAuthToken']}`,
        'content-type': 'application/x-www-form-urlencoded',
      },
      body: putData,
      method: 'PUT',
    },
  )

  let respJson = await resp.json()

  // it doesn't matter what the WAL server returns since this is fire-and-forget
  // return the same message as before
  return respJson['message']
}

/**
 * Gets the element tag information from the WAL server for a selectorId.
 * @param selectorId
 * @param tgConfig
 */
async function getInitialElementTag (selectorId, tgConfig) {
  const elemTagUrl = `${tgConfig['walServerHost']}/train/v1/css?selectorId=${selectorId}`

  let resp = await fetch(
    elemTagUrl,
    {
      headers: {
        Authorization: `Bearer ${tgConfig['walAuthToken']}`,
      },
      method: 'GET',
    },
  )

  if (!resp.ok) {
    return new Promise((resolve) => {
      resolve(null)
    })
  }

  let data = await resp.json()

  if (data['success'] === true) {
    return data['response']
  }

  return new Promise((resolve) => {
    resolve(null)
  })
}

/**
 * Finds similar elements to the target element.
 *
 * @param serializedElem the serialized web element object if the selector was successful, null otherwise
 * @param selector The CSS selector
 * @param selectorId The generated selectorId for this selector
 * @param $window The handle for the window object
 * @param $document The handle of the document object
 * @param tagMutationTable The tag mutation table
 * @param testGoldConfig The config object for the Interceptor
 * @param Cypress The Cypress object
 * @param cy The cy object
 */
async function findSimilarElements (
  serializedElem,
  selector,
  selectorId,
  $window, $document,
  tagMutationTable,
  testGoldConfig,
  Cypress,
  cy,
) {
  let similarCssSelector = 'body *'
  let similarElements
  let similarSerializedElements

  let filterVisible = testGoldConfig['interceptorFilterDisplayed']
  let filterEnabled = testGoldConfig['interceptorFilterEnabled']
  let neighborMaxDist = testGoldConfig['interceptorNeighborMaxDist']

  // if the tag mutation table is not present, use all elements in the DOM as 'similar elements'
  // apply filters in-line
  if (tagMutationTable === null) {
    similarElements = $document.querySelectorAll(similarCssSelector)
    similarSerializedElements = Array.from(similarElements).map((item) => {
      return serializeWebElement($window, item, Cypress, cy, filterVisible, filterEnabled, null)
    }).filter((value) => {
      if (value !== null) {
        return value
      }
    })

    return similarSerializedElements
  }

  // element tag set -- this will be used to figure out the selector for similar elements
  let selectorItems = new Set()

  // parse the selector and find the last selector's element tag
  const tokenizedSelector = parsel.tokenize(selector)
  const validElementTags = new Set(Object.getOwnPropertyNames(tagMutationTable))

  let lastElementTag = null

  for (let selectorInd = tokenizedSelector.length - 1; selectorInd >= 0; selectorInd--) {
    let selectorTokenValue = tokenizedSelector[selectorInd]['content']
    let selectorTokenType = tokenizedSelector[selectorInd]['type']

    if (selectorTokenType === 'type' && validElementTags.has(selectorTokenValue)) {
      lastElementTag = selectorTokenValue
      break
    }
  }

  // get the mutations of the selector's last element tag
  if (lastElementTag !== null) {
    selectorItems.add(lastElementTag)
    let tagMutations = tagMutationTable[lastElementTag] || []

    tagMutations.forEach((item) => selectorItems.add(item))
  }

  // serialized element properties
  let serializedElemTag = null
  let serializedElemX = null
  let serializedElemY = null

  // check if serializedElem exists and has a tag available
  // if it does, add its mutations to the tagMutations set
  if (serializedElem !== null) {
    serializedElemTag = serializedElem['tag']
    serializedElemX = serializedElem['x']
    serializedElemY = serializedElem['y']

    selectorItems.add(serializedElemTag)
    let tagMutations = tagMutationTable[serializedElemTag] || []

    tagMutations.forEach((item) => selectorItems.add(item))
  } else {
    // if it doesn't,
    // get the webElem info using the selectorId
    let serializedElemInfo

    try {
      serializedElemInfo = await getInitialElementTag(selectorId, testGoldConfig)
    } catch (err) {
      serializedElemInfo = null
    }

    if (serializedElemInfo !== null) {
      serializedElemTag = serializedElemInfo['tag']
      serializedElemX = serializedElemInfo['x']
      serializedElemY = serializedElemInfo['y']

      // we'll try to scroll the window to where this element was last seen on the page
      if (serializedElemInfo['elemViewTop'] !== undefined &&
          serializedElemInfo['elemViewBottom'] !== undefined) {
        $window.scrollTo(
          0, (serializedElemInfo['elemViewTop'] + serializedElemInfo['elemViewBottom']) / 2.0,
        )

        await awaitableTimeout(150)
      }

      selectorItems.add(serializedElemTag)
      let tagMutations = tagMutationTable[serializedElemTag] || []

      tagMutations.forEach((item) => selectorItems.add(item))
    }
  }

  if (selectorItems.size > 0) {
    similarCssSelector = Array.from(selectorItems).join(', ')
  } else {
    similarCssSelector = 'body *'
  }

  let neighborSpec = null

  if (serializedElemX !== null && serializedElemY !== null && neighborMaxDist > 0) {
    neighborSpec = [serializedElemX, serializedElemY, neighborMaxDist]
  }

  // execute the querySelectorAll command using the generated selector
  similarElements = $document.querySelectorAll(similarCssSelector)

  // serialize the selected elements and then filter by visibility, enabled state and nearest neighbors
  similarSerializedElements = Array.from(similarElements).map((item) => {
    return serializeWebElement($window, item, Cypress, cy, filterVisible, filterEnabled, neighborSpec)
  }).filter((value) => {
    if (value !== null) {
      return value
    }
  })

  return similarSerializedElements
}

module.exports = {
  awaitableTimeout,
  getSelectorId,
  serializeWebElement,
  getInterceptorConfig,
  getPageProperties,
  getTagMutationTable,
  startTestRequest,
  finishTestRequest,
  getInitialElementTag,
  findSimilarElements,
}
